// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import { FHE, euint32, externalEuint32 } from "@fhevm/solidity/lib/FHE.sol";
import { ZamaEthereumConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Input Proof Example
/// @notice Explains and demonstrates input proofs in FHEVM
/// @dev Input proofs ensure that encrypted inputs are correctly bound to the contract and user
contract InputProofExample is ZamaEthereumConfig {
  euint32 private _verifiedValue;

  event ValueStored(address indexed user);

  /// @notice What are input proofs?
  /// @dev Input proofs are zero-knowledge proofs that attest:
  ///      1. The encrypted value is correctly encrypted
  ///      2. The value is bound to the specific [contract, user] pair
  ///      3. The sender knows the plaintext value
  ///
  /// Why are they needed?
  /// - Prevent replay attacks (using someone else's encrypted data)
  /// - Ensure data integrity (encrypted value matches what user intended)
  /// - Bind encryption to specific contract context

  /// @notice CORRECT: Using input proof with encrypted input
  /// @dev This is the standard pattern for accepting encrypted inputs
  function storeValueWithProof(
    externalEuint32 encryptedInput,
    bytes calldata inputProof
  ) external {
    // FHE.fromExternal validates the input proof
    // It checks that:
    // 1. The proof is valid for this contract address
    // 2. The proof is valid for msg.sender
    // 3. The encrypted data matches the proof
    _verifiedValue = FHE.fromExternal(encryptedInput, inputProof);

    FHE.allowThis(_verifiedValue);
    FHE.allow(_verifiedValue, msg.sender);

    emit ValueStored(msg.sender);
  }

  /// @notice Example: How input proofs are generated (off-chain)
  /// @dev This is TypeScript pseudocode for educational purposes
  /**
   * // Off-chain (in tests or frontend):
   * const contractAddress = "0x...";
   * const userAddress = "0x...";
   * const plainValue = 42;
   *
   * // Create encrypted input with proof
   * const encryptedInput = await fhevm
   *   .createEncryptedInput(contractAddress, userAddress)
   *   .add32(plainValue)
   *   .encrypt();
   *
   * // Call contract
   * await contract.storeValueWithProof(
   *   encryptedInput.handles[0],  // The encrypted value
   *   encryptedInput.inputProof   // The zero-knowledge proof
   * );
   */

  /// @notice ANTI-PATTERN: Accepting encrypted data without proof
  /// @dev This function shows what NOT to do
  /// @custom:warning Never use this pattern in production!
  function storeValueWithoutProof(bytes calldata encryptedInput) external {
    // WRONG: Converting bytes directly without proof validation
    // This bypasses security checks!
    euint32 unsafeValue = FHE.asEuint8(encryptedInput);

    // This is unsafe because:
    // 1. No proof that sender encrypted this data
    // 2. No binding to contract/user pair
    // 3. Vulnerable to replay attacks
    // 4. Data integrity not verified

    _verifiedValue = unsafeValue;  // DON'T DO THIS!
  }

  /// @notice Common mistake: Wrong signer for input proof
  /// @dev Input proof must be generated by the transaction sender
  function storeValueCorrectSigner(
    externalEuint32 encryptedInput,
    bytes calldata inputProof
  ) external {
    // This will succeed if:
    // - inputProof was created with msg.sender's address
    // - The encrypted input was bound to this contract and msg.sender

    _verifiedValue = FHE.fromExternal(encryptedInput, inputProof);

    FHE.allowThis(_verifiedValue);
    FHE.allow(_verifiedValue, msg.sender);
  }

  /// @notice Example: What happens with wrong signer
  /// @dev If Alice generates proof but Bob sends transaction, it will fail
  /**
   * // WRONG:
   * // Alice generates the encrypted input
   * const aliceInput = await fhevm
   *   .createEncryptedInput(contractAddress, alice.address)
   *   .add32(42)
   *   .encrypt();
   *
   * // Bob tries to use Alice's encrypted input
   * await contract.connect(bob).storeValueWithProof(
   *   aliceInput.handles[0],
   *   aliceInput.inputProof  // This will fail! Proof is for Alice, not Bob
   * );
   *
   * // CORRECT:
   * // Bob generates his own encrypted input
   * const bobInput = await fhevm
   *   .createEncryptedInput(contractAddress, bob.address)
   *   .add32(42)
   *   .encrypt();
   *
   * await contract.connect(bob).storeValueWithProof(
   *   bobInput.handles[0],
   *   bobInput.inputProof  // This works! Proof is for Bob
   * );
   */

  /// @notice Gets the stored verified value
  function getValue() external view returns (euint32) {
    return _verifiedValue;
  }
}
