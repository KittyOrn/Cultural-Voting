// SPDX-License-Identifier: BSD-3-Clause-Clear
pragma solidity ^0.8.24;

import { FHE, euint32, externalEuint32 } from "@fhevm/solidity/lib/FHE.sol";
import { ZamaEthereumConfig } from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title Common FHEVM Anti-Patterns
/// @notice Demonstrates what NOT to do when working with encrypted values
/// @dev This contract shows common mistakes and their correct alternatives
contract AntiPatterns is ZamaEthereumConfig {
  euint32 private _data;

  // ====== ANTI-PATTERN 1: View Functions with Encrypted Returns ======

  /// @notice ANTI-PATTERN: Using view function to return encrypted value for decryption
  /// @dev This WILL NOT WORK for user decryption
  /// @custom:warning View functions cannot grant FHE.allow permissions!
  function getDataViewFunction() external view returns (euint32) {
    // WRONG: View functions are read-only and cannot:
    // 1. Call FHE.allowThis()
    // 2. Call FHE.allow() to grant permissions
    // 3. Make state changes
    // Users cannot decrypt values from view functions!
    return _data;
  }

  /// @notice CORRECT: Use non-view function for decryptable values
  /// @dev State-changing function that grants permission for decryption
  function getDataForDecryption() external returns (euint32) {
    // CORRECT: Non-view functions can:
    // 1. Call FHE.allow() to grant permissions
    // 2. Make state changes
    // 3. Enable user decryption
    FHE.allow(_data, msg.sender);
    return _data;
  }

  // ====== ANTI-PATTERN 2: Missing allowThis Permission ======

  /// @notice ANTI-PATTERN: Only granting user permission, not contract permission
  function storeDataIncorrect(externalEuint32 input, bytes calldata proof) external {
    euint32 value = FHE.fromExternal(input, proof);

    // WRONG: Only giving user permission
    FHE.allow(value, msg.sender);
    // Missing: FHE.allowThis(value);

    // This will FAIL because contract doesn't have permission to store!
    _data = value;
  }

  /// @notice CORRECT: Grant both contract and user permissions
  function storeDataCorrect(externalEuint32 input, bytes calldata proof) external {
    euint32 value = FHE.fromExternal(input, proof);

    // CORRECT: Grant both permissions
    FHE.allowThis(value);  // Contract can store/use
    FHE.allow(value, msg.sender);  // User can decrypt

    _data = value;  // This works!
  }

  // ====== ANTI-PATTERN 3: Input Proof Signer Mismatch ======

  /// @notice ANTI-PATTERN: Using proof from different signer
  /// @dev Input proof must be generated by msg.sender
  function storeDataWrongSigner(externalEuint32 input, bytes calldata proof) external {
    // If 'proof' was generated by Alice but Bob calls this function,
    // FHE.fromExternal will REVERT because proof doesn't match msg.sender

    // WRONG: Trying to use someone else's proof
    // euint32 value = FHE.fromExternal(input, proof);  // Fails!
  }

  /// @notice CORRECT: Each user must provide their own proof
  function storeDataCorrectSigner(externalEuint32 input, bytes calldata proof) external {
    // Each user generates their own encrypted input with proof
    // The proof binds to [this contract, msg.sender]
    euint32 value = FHE.fromExternal(input, proof);

    FHE.allowThis(value);
    FHE.allow(value, msg.sender);

    _data = value;
  }

  // ====== ANTI-PATTERN 4: Leaking Information Through State Changes ======

  mapping(address => bool) public hasVoted;  // Public mapping - leaks voting info!

  /// @notice ANTI-PATTERN: Public mapping reveals encrypted action info
  function votePublicMapping(externalEuint32 vote, bytes calldata proof) external {
    // WRONG: Public mapping reveals WHO voted
    // Even though vote is encrypted, the fact that someone voted is public
    hasVoted[msg.sender] = true;  // This reveals voting activity!
  }

  /// @notice CORRECT: Use encrypted records or private mapping
  mapping(address => euint32) private encryptedVotes;  // Private mapping

  function voteCorrect(externalEuint32 vote, bytes calldata proof) external {
    euint32 encryptedVote = FHE.fromExternal(vote, proof);

    FHE.allowThis(encryptedVote);
    FHE.allow(encryptedVote, msg.sender);

    // CORRECT: Use private mapping to prevent information leakage
    encryptedVotes[msg.sender] = encryptedVote;
  }

  // ====== ANTI-PATTERN 5: Using Encrypted Values in Conditions ======

  /// @notice ANTI-PATTERN: Conditional logic based on encrypted values
  /// @dev You cannot directly compare encrypted values in if statements
  function transferIfGreaterIncorrect(
    externalEuint32 amount,
    bytes calldata proof,
    uint256 threshold
  ) external {
    euint32 encryptedAmount = FHE.fromExternal(amount, proof);

    // WRONG: Cannot use encrypted value in if condition!
    // if (encryptedAmount > threshold) {  // Compilation error!
    //     // transfer...
    // }
    // Encrypted values don't support direct comparison

    // Note: Do not attempt to reveal via type conversion!
  }

  /// @notice CORRECT: Use FHE operations for comparisons
  function transferIfGreaterCorrect(
    externalEuint32 amount,
    bytes calldata proof
  ) external {
    euint32 encryptedAmount = FHE.fromExternal(amount, proof);

    // CORRECT: Use FHE operations for encrypted comparisons
    // Returns encrypted boolean - cannot be used directly in if
    // Must either:
    // 1. Request public decryption via FHE.requestDecryption
    // 2. Use homomorphic operations throughout
  }

  // ====== ANTI-PATTERN 6: Type Confusion ======

  /// @notice ANTI-PATTERN: Incorrect type conversions
  function typeConfusionIncorrect(bytes calldata data) external {
    // WRONG: Using wrong type conversions
    // euint32 value = FHE.asEuint8(data);  // Wrong type!
    // Different encrypted types are not compatible
  }

  /// @notice CORRECT: Use matching types
  function typeConfusionCorrect(bytes calldata data) external {
    // CORRECT: Ensure type matches the encrypted data
    euint32 value = FHE.asEuint32(data);
    FHE.allowThis(value);
    _data = value;
  }

  // ====== SUMMARY OF ANTI-PATTERNS ======

  /**
   * COMMON ANTI-PATTERNS TO AVOID:
   *
   * 1. View Functions for Decryption
   *    ❌ Cannot grant permissions in view functions
   *    ✅ Use non-view functions for user decryption
   *
   * 2. Missing FHE.allowThis
   *    ❌ FHE.allow(value, user) only
   *    ✅ Always use both FHE.allowThis(value) and FHE.allow(value, user)
   *
   * 3. Wrong Input Proof Signer
   *    ❌ Using another user's proof
   *    ✅ Each user generates their own proof with their address
   *
   * 4. Information Leakage
   *    ❌ Public mappings of encrypted activities
   *    ✅ Use private mappings and encrypted states
   *
   * 5. Direct Encrypted Comparisons
   *    ❌ if (encryptedValue > 100) { ... }
   *    ✅ Use FHE.eq, FHE.le, etc. or request decryption
   *
   * 6. Type Mismatches
   *    ❌ FHE.asEuint8(data meant for euint32)
   *    ✅ Ensure type matches encrypted data
   *
   * 7. Forgot to Bind to Contract
   *    ❌ FHE.allow(value, user) only
   *    ✅ FHE.allowThis(value) + FHE.allow(value, user)
   */
}
